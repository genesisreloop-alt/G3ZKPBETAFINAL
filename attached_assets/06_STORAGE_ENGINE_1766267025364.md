# G3ZKP Implementation Plan - Part 06
## Storage Engine

---

## 1. STORAGE ENGINE

**File: `packages/storage/src/storage-engine.ts`**

```typescript
import { openDB, IDBPDatabase } from 'idb';
import { Message, Session, ZKProof, StorageConfig } from '@g3zkp/core';
import { StorageEncryption } from './storage-encryption';
import { LRUCache } from 'lru-cache';

interface G3ZKPDatabase {
  messages: Message;
  sessions: Session;
  proofs: ZKProof;
  keys: { id: string; key: Uint8Array; createdAt: Date };
  metadata: { key: string; value: any };
}

export class StorageEngine {
  private db: IDBPDatabase<G3ZKPDatabase> | null = null;
  private config: StorageConfig;
  private encryption: StorageEncryption;
  private cache: LRUCache<string, any>;

  constructor(config: StorageConfig) {
    this.config = config;
    this.encryption = new StorageEncryption();
    this.cache = new LRUCache({
      max: 1000,
      maxSize: config.cacheSize,
      sizeCalculation: (value) => JSON.stringify(value).length
    });
  }

  async initialize(): Promise<void> {
    this.db = await openDB<G3ZKPDatabase>('g3zkp', 1, {
      upgrade(db) {
        const messagesStore = db.createObjectStore('messages', { keyPath: 'id' });
        messagesStore.createIndex('conversationId', 'conversationId');
        messagesStore.createIndex('timestamp', 'timestamp');
        messagesStore.createIndex('status', 'status');

        const sessionsStore = db.createObjectStore('sessions', { keyPath: 'id' });
        sessionsStore.createIndex('keyId', 'keyId');
        sessionsStore.createIndex('lastActivity', 'lastActivity');

        const proofsStore = db.createObjectStore('proofs', { keyPath: 'metadata.proofId' });
        proofsStore.createIndex('circuitId', 'circuitId');
        proofsStore.createIndex('timestamp', 'metadata.timestamp');

        db.createObjectStore('keys', { keyPath: 'id' });
        db.createObjectStore('metadata', { keyPath: 'key' });
      }
    });

    await this.encryption.initialize();
  }

  async saveMessage(message: Message): Promise<void> {
    if (!this.db) throw new Error('Storage not initialized');

    const encrypted = this.config.encryptAtRest
      ? await this.encryption.encrypt(message)
      : message;

    await this.db.put('messages', encrypted);
    this.cache.set(`msg:${message.id}`, message);
  }

  async getMessage(id: string): Promise<Message | null> {
    const cached = this.cache.get(`msg:${id}`);
    if (cached) return cached as Message;

    if (!this.db) throw new Error('Storage not initialized');

    const stored = await this.db.get('messages', id);
    if (!stored) return null;

    const message = this.config.encryptAtRest
      ? await this.encryption.decrypt(stored)
      : stored;

    this.cache.set(`msg:${id}`, message);
    return message;
  }

  async getMessagesByConversation(
    conversationId: string,
    limit = 50,
    before?: Date
  ): Promise<Message[]> {
    if (!this.db) throw new Error('Storage not initialized');

    const index = this.db.transaction('messages').store.index('conversationId');
    const messages: Message[] = [];

    for await (const cursor of index.iterate(conversationId)) {
      if (before && cursor.value.timestamp >= before) continue;
      
      const message = this.config.encryptAtRest
        ? await this.encryption.decrypt(cursor.value)
        : cursor.value;
      
      messages.push(message);
      if (messages.length >= limit) break;
    }

    return messages.sort((a, b) => 
      b.timestamp.getTime() - a.timestamp.getTime()
    );
  }

  async saveSession(session: Session): Promise<void> {
    if (!this.db) throw new Error('Storage not initialized');

    const encrypted = this.config.encryptAtRest
      ? await this.encryption.encrypt(session)
      : session;

    await this.db.put('sessions', encrypted);
    this.cache.set(`session:${session.id}`, session);
  }

  async getSession(id: string): Promise<Session | null> {
    const cached = this.cache.get(`session:${id}`);
    if (cached) return cached as Session;

    if (!this.db) throw new Error('Storage not initialized');

    const stored = await this.db.get('sessions', id);
    if (!stored) return null;

    const session = this.config.encryptAtRest
      ? await this.encryption.decrypt(stored)
      : stored;

    this.cache.set(`session:${id}`, session);
    return session;
  }

  async saveProof(proof: ZKProof): Promise<void> {
    if (!this.db) throw new Error('Storage not initialized');
    await this.db.put('proofs', proof);
  }

  async getProof(proofId: string): Promise<ZKProof | null> {
    if (!this.db) throw new Error('Storage not initialized');
    return await this.db.get('proofs', proofId) || null;
  }

  async deleteMessagesBefore(timestamp: number): Promise<number> {
    if (!this.db) throw new Error('Storage not initialized');

    const tx = this.db.transaction('messages', 'readwrite');
    const index = tx.store.index('timestamp');
    let deleted = 0;

    for await (const cursor of index.iterate(IDBKeyRange.upperBound(new Date(timestamp)))) {
      await cursor.delete();
      this.cache.delete(`msg:${cursor.value.id}`);
      deleted++;
    }

    await tx.done;
    return deleted;
  }

  async deleteProofsBefore(timestamp: number): Promise<number> {
    if (!this.db) throw new Error('Storage not initialized');

    const tx = this.db.transaction('proofs', 'readwrite');
    const index = tx.store.index('timestamp');
    let deleted = 0;

    for await (const cursor of index.iterate(IDBKeyRange.upperBound(new Date(timestamp)))) {
      await cursor.delete();
      deleted++;
    }

    await tx.done;
    return deleted;
  }

  async compact(): Promise<{ freedBytes: number }> {
    // IndexedDB doesn't support explicit compaction
    // Return cache stats instead
    const beforeSize = this.cache.calculatedSize || 0;
    this.cache.purgeStale();
    const afterSize = this.cache.calculatedSize || 0;
    return { freedBytes: beforeSize - afterSize };
  }

  async close(): Promise<void> {
    this.cache.clear();
    this.db?.close();
    this.db = null;
  }
}
```

---

## 2. STORAGE ENCRYPTION

**File: `packages/storage/src/storage-encryption.ts`**

```typescript
import { secretbox, randomBytes } from 'tweetnacl';
import { hkdf } from '@g3zkp/crypto';

export class StorageEncryption {
  private masterKey: Uint8Array | null = null;

  async initialize(): Promise<void> {
    // In production, derive from user password or secure enclave
    const stored = localStorage.getItem('g3zkp_storage_key');
    if (stored) {
      this.masterKey = new Uint8Array(JSON.parse(stored));
    } else {
      this.masterKey = randomBytes(32);
      localStorage.setItem('g3zkp_storage_key', JSON.stringify([...this.masterKey]));
    }
  }

  async encrypt(data: any): Promise<any> {
    if (!this.masterKey) throw new Error('Encryption not initialized');

    const plaintext = new TextEncoder().encode(JSON.stringify(data));
    const nonce = randomBytes(secretbox.nonceLength);
    const key = await this.deriveKey(nonce);
    const ciphertext = secretbox(plaintext, nonce, key);

    return {
      __encrypted: true,
      nonce: [...nonce],
      data: [...ciphertext]
    };
  }

  async decrypt(encrypted: any): Promise<any> {
    if (!encrypted.__encrypted) return encrypted;
    if (!this.masterKey) throw new Error('Encryption not initialized');

    const nonce = new Uint8Array(encrypted.nonce);
    const ciphertext = new Uint8Array(encrypted.data);
    const key = await this.deriveKey(nonce);
    
    const plaintext = secretbox.open(ciphertext, nonce, key);
    if (!plaintext) throw new Error('Decryption failed');

    return JSON.parse(new TextDecoder().decode(plaintext));
  }

  private async deriveKey(nonce: Uint8Array): Promise<Uint8Array> {
    return await hkdf(
      this.masterKey!,
      32,
      nonce,
      'SHA-256'
    );
  }
}
```

---

## 3. MATRIX-COMPATIBLE STORAGE SCHEMA

**File: `packages/storage/src/matrix-schema.ts`**

```typescript
import { openDB, IDBPDatabase } from 'idb';

interface MatrixCompatibleDB {
  messages: StoredMessage;
  rooms: StoredRoom;
  room_state: StoredRoomState;
  room_members: StoredRoomMember;
  device_keys: StoredDeviceKeys;
  one_time_keys: StoredOneTimeKey;
  invitations: StoredInvitation;
  presence: StoredPresence;
  account_data: StoredAccountData;
  read_receipts: StoredReadReceipt;
  typing: StoredTyping;
  transactions: StoredTransaction;
  proofs: StoredProof;
  room_aliases: StoredRoomAlias;
  media: StoredMedia;
}

export async function createMatrixCompatibleDB(): Promise<IDBPDatabase<MatrixCompatibleDB>> {
  return openDB<MatrixCompatibleDB>('g3zkp-protocol', 4, {
    upgrade(db) {
      // Messages (Matrix: timeline events)
      if (!db.objectStoreNames.contains('messages')) {
        const store = db.createObjectStore('messages', { keyPath: ['room_id', 'message_id'] });
        store.createIndex('room_timestamp', ['room_id', 'timestamp']);
        store.createIndex('sender', ['sender_key', 'timestamp']);
        store.createIndex('thread', ['room_id', 'relates_to', 'timestamp']);
        store.createIndex('redacted', ['room_id', 'redacted', 'timestamp']);
      }

      // Rooms (Matrix: room list)
      if (!db.objectStoreNames.contains('rooms')) {
        const store = db.createObjectStore('rooms', { keyPath: 'room_id' });
        store.createIndex('membership', ['membership', 'last_event']);
        store.createIndex('creator', ['creator', 'created_at']);
        store.createIndex('alias', ['aliases'], { multiEntry: true });
      }

      // Room State (Matrix: state events)
      if (!db.objectStoreNames.contains('room_state')) {
        const store = db.createObjectStore('room_state', { keyPath: ['room_id', 'type', 'state_key'] });
        store.createIndex('room_type', ['room_id', 'type']);
        store.createIndex('state_key', 'state_key');
      }

      // Room Members (Matrix: m.room.member)
      if (!db.objectStoreNames.contains('room_members')) {
        const store = db.createObjectStore('room_members', { keyPath: ['room_id', 'user_id'] });
        store.createIndex('user_rooms', ['user_id', 'room_id']);
        store.createIndex('membership', ['room_id', 'membership']);
      }

      // Device Keys (Matrix: device_keys)
      if (!db.objectStoreNames.contains('device_keys')) {
        const store = db.createObjectStore('device_keys', { keyPath: ['user_id', 'device_id'] });
        store.createIndex('user_devices', 'user_id');
        store.createIndex('device_key', 'device_id');
      }

      // One-Time Keys (Matrix: one_time_keys)
      if (!db.objectStoreNames.contains('one_time_keys')) {
        const store = db.createObjectStore('one_time_keys', { keyPath: ['user_id', 'device_id', 'key_id'] });
        store.createIndex('device_keys', ['user_id', 'device_id']);
      }

      // Invitations (Matrix: invite state)
      if (!db.objectStoreNames.contains('invitations')) {
        const store = db.createObjectStore('invitations', { keyPath: ['room_id', 'user_id'] });
        store.createIndex('user_invites', 'user_id');
        store.createIndex('room_invites', 'room_id');
      }

      // Presence (Matrix: presence events)
      if (!db.objectStoreNames.contains('presence')) {
        const store = db.createObjectStore('presence', { keyPath: 'user_id' });
        store.createIndex('last_active', 'last_active');
        store.createIndex('presence', 'presence');
      }

      // Account Data (Matrix: account_data)
      if (!db.objectStoreNames.contains('account_data')) {
        const store = db.createObjectStore('account_data', { keyPath: ['user_id', 'type'] });
        store.createIndex('user_data', 'user_id');
      }

      // Read Receipts (Matrix: m.receipt)
      if (!db.objectStoreNames.contains('read_receipts')) {
        const store = db.createObjectStore('read_receipts', { keyPath: ['room_id', 'user_id', 'event_id'] });
        store.createIndex('room_receipts', ['room_id', 'event_id']);
        store.createIndex('user_read', ['user_id', 'room_id', 'timestamp']);
      }

      // Typing (Matrix: m.typing)
      if (!db.objectStoreNames.contains('typing')) {
        const store = db.createObjectStore('typing', { keyPath: ['room_id', 'user_id'] });
        store.createIndex('room_typing', 'room_id');
      }

      // Transactions (idempotency)
      if (!db.objectStoreNames.contains('transactions')) {
        const store = db.createObjectStore('transactions', { keyPath: 'txn_id' });
        store.createIndex('room_transactions', ['room_id', 'timestamp']);
      }

      // ZKP Proofs
      if (!db.objectStoreNames.contains('proofs')) {
        const store = db.createObjectStore('proofs', { keyPath: 'proof_id' });
        store.createIndex('message_proof', 'message_id', { unique: true });
        store.createIndex('circuit', 'circuit_id');
        store.createIndex('timestamp', 'generated_at');
      }

      // Room Aliases (Matrix: m.room.aliases via IPNS)
      if (!db.objectStoreNames.contains('room_aliases')) {
        const store = db.createObjectStore('room_aliases', { keyPath: 'alias' });
        store.createIndex('room_aliases', 'room_id');
      }

      // Media (encrypted blobs)
      if (!db.objectStoreNames.contains('media')) {
        const store = db.createObjectStore('media', { keyPath: 'media_id' });
        store.createIndex('room_media', 'room_id');
        store.createIndex('mime_type', 'mime_type');
        store.createIndex('timestamp', 'timestamp');
      }
    }
  });
}

// Type definitions for stored records
interface StoredMessage {
  room_id: string;
  message_id: string;
  sender_key: string;
  timestamp: Date;
  content: any;
  relates_to?: string;
  relates_to_type?: string;
  redacted: boolean;
  redaction_reason?: string;
  via?: string[];
  stored_at: Date;
}

interface StoredRoom {
  room_id: string;
  creator: string;
  version: string;
  membership: 'join' | 'invite' | 'leave' | 'ban';
  member_count: number;
  aliases?: string[];
  last_event: number;
  created_at: Date;
}

interface StoredRoomState {
  room_id: string;
  type: number;
  state_key: string;
  content: Uint8Array;
  prev_state_id?: string;
  prev_content?: Uint8Array;
  membership?: string;
  reason?: string;
  stored_at: Date;
}

interface StoredRoomMember {
  room_id: string;
  user_id: string;
  membership: 'join' | 'invite' | 'leave' | 'ban' | 'knock';
  display_name?: string;
  avatar_url?: string;
  joined_at?: Date;
  left_at?: Date;
  power_level: number;
  updated_at: Date;
}

interface StoredDeviceKeys {
  user_id: string;
  device_id: string;
  keys: any;
  algorithms: Record<string, string>;
  signatures: any;
  proof: any;
  uploaded_at: Date;
  expires_at?: Date;
}

interface StoredOneTimeKey {
  user_id: string;
  device_id: string;
  key_id: string;
  key: string;
  algorithm: string;
  created_at: Date;
  used_at?: Date;
}

interface StoredInvitation {
  room_id: string;
  user_id: string;
  sender: string;
  event: any;
  proof: any;
  room_state?: any;
  received_at: Date;
}

interface StoredPresence {
  user_id: string;
  presence: 'online' | 'offline' | 'unavailable';
  status_msg?: string;
  last_active: Date;
  currently_active: boolean;
  proof: any;
  updated_at: Date;
}

interface StoredAccountData {
  user_id: string;
  type: string;
  content: any;
  updated_at: Date;
}

interface StoredReadReceipt {
  room_id: string;
  user_id: string;
  event_id: string;
  receipt_type: string;
  timestamp: Date;
  proof: any;
  stored_at: Date;
}

interface StoredTyping {
  room_id: string;
  user_id: string;
  typing: boolean;
  timeout_ms: number;
  expires_at: Date;
}

interface StoredTransaction {
  txn_id: string;
  room_id: string;
  message_id: string;
  status: 'pending' | 'sent' | 'failed';
  timestamp: Date;
  metadata?: any;
}

interface StoredProof {
  proof_id: string;
  message_id: string;
  circuit_id: string;
  proof: string;
  public_signals: string[];
  generated_at: Date;
  prover_id: string;
  metadata: any;
  stored_at: Date;
}

interface StoredRoomAlias {
  alias: string;
  room_id: string;
  creator: string;
  ipns_record?: any;
  proof: any;
  created_at: Date;
  expires_at?: Date;
}

interface StoredMedia {
  media_id: string;
  room_id: string;
  mime_type: string;
  size: number;
  data: Uint8Array;
  thumbnail?: Uint8Array;
  thumbnail_info?: any;
  encryption?: any;
  uploaded_at: Date;
  expires_at?: Date;
}
```

---

## 4. MATRIX STORAGE MAPPING

| Matrix Storage | G3ZKP Storage | Notes |
|----------------|---------------|-------|
| Room events | `messages` store | Timeline events with ZKP proofs |
| State events | `room_state` store | CRDT-compatible state |
| Room membership | `room_members` store | With ZKP membership proofs |
| Device keys | `device_keys` store | DHT-synchronized |
| One-time keys | `one_time_keys` store | Consumed on claim |
| Invitations | `invitations` store | With invitation proofs |
| Presence | `presence` store | DHT + PubSub synced |
| Account data | `account_data` store | User preferences |
| Read receipts | `read_receipts` store | With read proofs |
| Typing indicators | `typing` store | Ephemeral, auto-expire |
| Room aliases | `room_aliases` store | IPNS-backed |

---

*Next: Part 07 - Security Audit System*
