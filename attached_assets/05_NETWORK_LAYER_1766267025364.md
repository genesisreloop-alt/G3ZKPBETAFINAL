# G3ZKP Implementation Plan - Part 05
## Network Layer

---

## 1. NETWORK ENGINE

**File: `packages/network/src/network-engine.ts`**

```typescript
import { createLibp2p, Libp2p } from 'libp2p';
import { webSockets } from '@libp2p/websockets';
import { webRTC } from '@libp2p/webrtc';
import { noise } from '@chainsafe/libp2p-noise';
import { yamux } from '@chainsafe/libp2p-yamux';
import { gossipsub } from '@chainsafe/libp2p-gossipsub';
import { kadDHT } from '@libp2p/kad-dht';
import { bootstrap } from '@libp2p/bootstrap';
import { PeerInfo, Message, MessageReceipt, NetworkConfig } from '@g3zkp/core';
import { EventEmitter } from '@g3zkp/core';

interface NetworkEvents {
  'peer:connected': PeerInfo;
  'peer:disconnected': { peerId: string };
  'message:received': { from: string; data: Uint8Array };
  'error': Error;
}

export class NetworkEngine extends EventEmitter<NetworkEvents> {
  private node: Libp2p | null = null;
  private config: NetworkConfig;
  private connections: Map<string, any> = new Map();

  constructor(config: NetworkConfig) {
    super();
    this.config = config;
  }

  async initialize(): Promise<void> {
    this.node = await createLibp2p({
      transports: [webSockets(), webRTC()],
      connectionEncryption: [noise()],
      streamMuxers: [yamux()],
      peerDiscovery: [
        bootstrap({ list: this.config.bootstrapNodes })
      ],
      services: {
        pubsub: gossipsub({
          emitSelf: false,
          gossipIncoming: true,
          fallbackToFloodsub: true
        }),
        dht: kadDHT({ clientMode: true })
      },
      connectionManager: {
        maxConnections: this.config.maxConnections,
        minConnections: 5
      }
    });

    this.setupEventHandlers();
    await this.node.start();
    console.log(`Node started: ${this.node.peerId.toString()}`);
  }

  private setupEventHandlers(): void {
    if (!this.node) return;

    this.node.addEventListener('peer:connect', (evt) => {
      const peerId = evt.detail.toString();
      this.emit('peer:connected', {
        id: peerId,
        addresses: [],
        protocols: [],
        metadata: { discoveryMethod: 'direct', lastSeen: new Date() }
      });
    });

    this.node.addEventListener('peer:disconnect', (evt) => {
      this.emit('peer:disconnected', { peerId: evt.detail.toString() });
    });

    this.node.services.pubsub.addEventListener('message', (evt) => {
      this.emit('message:received', {
        from: evt.detail.from.toString(),
        data: evt.detail.data
      });
    });
  }

  async sendMessage(peerId: string, data: Uint8Array): Promise<MessageReceipt> {
    if (!this.node) throw new Error('Node not initialized');

    const stream = await this.node.dialProtocol(peerId, '/g3zkp/message/1.0.0');
    
    await stream.sink([data]);
    await stream.close();

    return {
      messageId: crypto.randomUUID(),
      recipientId: peerId,
      timestamp: new Date(),
      status: 'sent',
      method: 'direct'
    };
  }

  async publishMessage(topic: string, data: Uint8Array): Promise<MessageReceipt> {
    if (!this.node) throw new Error('Node not initialized');

    await this.node.services.pubsub.publish(topic, data);

    return {
      messageId: crypto.randomUUID(),
      recipientId: topic,
      timestamp: new Date(),
      status: 'published',
      method: 'pubsub',
      topic
    };
  }

  async subscribe(topic: string): Promise<void> {
    if (!this.node) throw new Error('Node not initialized');
    this.node.services.pubsub.subscribe(topic);
  }

  async unsubscribe(topic: string): Promise<void> {
    if (!this.node) throw new Error('Node not initialized');
    this.node.services.pubsub.unsubscribe(topic);
  }

  async findPeer(peerId: string): Promise<PeerInfo | null> {
    if (!this.node) throw new Error('Node not initialized');

    try {
      const peer = await this.node.peerStore.get(peerId);
      return {
        id: peer.id.toString(),
        addresses: peer.addresses.map(a => a.multiaddr.toString()),
        protocols: [...peer.protocols],
        metadata: { discoveryMethod: 'dht', lastSeen: new Date() }
      };
    } catch {
      return null;
    }
  }

  getConnectedPeers(): string[] {
    if (!this.node) return [];
    return this.node.getConnections().map(c => c.remotePeer.toString());
  }

  getPeerId(): string {
    return this.node?.peerId.toString() || '';
  }

  async shutdown(): Promise<void> {
    if (this.node) {
      await this.node.stop();
      this.node = null;
    }
  }
}
```

---

## 2. PEER DISCOVERY

**File: `packages/network/src/peer-discovery.ts`**

```typescript
import { PeerInfo } from '@g3zkp/core';
import { NetworkEngine } from './network-engine';

export class PeerDiscovery {
  private engine: NetworkEngine;
  private knownPeers: Map<string, PeerInfo> = new Map();
  private discoveryInterval: NodeJS.Timeout | null = null;

  constructor(engine: NetworkEngine) {
    this.engine = engine;
  }

  async start(): Promise<void> {
    this.discoveryInterval = setInterval(
      () => this.runDiscovery(),
      30000
    );
    await this.runDiscovery();
  }

  async stop(): Promise<void> {
    if (this.discoveryInterval) {
      clearInterval(this.discoveryInterval);
      this.discoveryInterval = null;
    }
  }

  private async runDiscovery(): Promise<void> {
    const connected = this.engine.getConnectedPeers();
    
    for (const peerId of connected) {
      if (!this.knownPeers.has(peerId)) {
        const info = await this.engine.findPeer(peerId);
        if (info) {
          this.knownPeers.set(peerId, info);
        }
      }
    }

    // Remove stale peers
    const now = Date.now();
    for (const [id, peer] of this.knownPeers) {
      if (now - peer.metadata.lastSeen.getTime() > 5 * 60 * 1000) {
        this.knownPeers.delete(id);
      }
    }
  }

  getKnownPeers(): PeerInfo[] {
    return [...this.knownPeers.values()];
  }

  getPeerCount(): number {
    return this.knownPeers.size;
  }
}
```

---

## 3. MESSAGE PROTOCOL

**File: `packages/network/src/message-protocol.ts`**

```typescript
import { Message, EncryptedMessage } from '@g3zkp/core';
import { NetworkEngine } from './network-engine';

export interface MessageEnvelope {
  version: number;
  type: 'direct' | 'broadcast' | 'group';
  payload: Uint8Array;
  signature: Uint8Array;
  timestamp: number;
  ttl: number;
}

export class MessageProtocol {
  private engine: NetworkEngine;
  private messageHandlers: Map<string, (msg: MessageEnvelope) => void> = new Map();

  constructor(engine: NetworkEngine) {
    this.engine = engine;
    this.setupHandlers();
  }

  private setupHandlers(): void {
    this.engine.on('message:received', ({ from, data }) => {
      try {
        const envelope = this.deserializeEnvelope(data);
        this.handleMessage(from, envelope);
      } catch (error) {
        console.error('Failed to handle message:', error);
      }
    });
  }

  async sendDirect(
    recipientId: string,
    encrypted: EncryptedMessage
  ): Promise<void> {
    const envelope = this.createEnvelope('direct', encrypted);
    const data = this.serializeEnvelope(envelope);
    await this.engine.sendMessage(recipientId, data);
  }

  async broadcast(
    topic: string,
    encrypted: EncryptedMessage
  ): Promise<void> {
    const envelope = this.createEnvelope('broadcast', encrypted);
    const data = this.serializeEnvelope(envelope);
    await this.engine.publishMessage(topic, data);
  }

  onMessage(type: string, handler: (msg: MessageEnvelope) => void): void {
    this.messageHandlers.set(type, handler);
  }

  private handleMessage(from: string, envelope: MessageEnvelope): void {
    if (Date.now() - envelope.timestamp > envelope.ttl) {
      return; // Message expired
    }

    const handler = this.messageHandlers.get(envelope.type);
    if (handler) {
      handler(envelope);
    }
  }

  private createEnvelope(
    type: 'direct' | 'broadcast' | 'group',
    encrypted: EncryptedMessage
  ): MessageEnvelope {
    return {
      version: 1,
      type,
      payload: this.serializeMessage(encrypted),
      signature: new Uint8Array(64), // TODO: Sign with identity key
      timestamp: Date.now(),
      ttl: 5 * 60 * 1000 // 5 minutes
    };
  }

  private serializeEnvelope(envelope: MessageEnvelope): Uint8Array {
    return new TextEncoder().encode(JSON.stringify(envelope));
  }

  private deserializeEnvelope(data: Uint8Array): MessageEnvelope {
    return JSON.parse(new TextDecoder().decode(data));
  }

  private serializeMessage(msg: EncryptedMessage): Uint8Array {
    return new TextEncoder().encode(JSON.stringify(msg));
  }
}
```

---

## 4. MATRIX FEDERATION MAPPING

**File: `packages/network/src/federation.ts`**

```typescript
import { NetworkEngine } from './network-engine';
import { G3ZKPMessage, RoomState, ToDeviceMessage } from '@g3zkp/protocol';

export interface RoomTopic {
  id: string;
  name: string;
  subscribers: Set<string>;
  messages: G3ZKPMessage[];
  createdAt: Date;
  stats: { messageCount: number; subscriberCount: number; lastMessageTime: Date | null };
}

export class FederationNetwork {
  private engine: NetworkEngine;
  private topics: Map<string, RoomTopic> = new Map();
  private dht: any;

  constructor(engine: NetworkEngine) {
    this.engine = engine;
  }

  // Matrix: Room creation → Topic creation
  async createRoomTopic(roomId: string): Promise<RoomTopic> {
    const topicName = `/g3zkp/rooms/${roomId}`;
    const topic: RoomTopic = {
      id: roomId,
      name: topicName,
      subscribers: new Set(),
      messages: [],
      createdAt: new Date(),
      stats: { messageCount: 0, subscriberCount: 0, lastMessageTime: null }
    };

    await this.engine.subscribe(topicName);
    this.topics.set(roomId, topic);
    return topic;
  }

  // Matrix: Room join → Topic subscription
  async subscribeToRoom(roomId: string): Promise<void> {
    const topicName = `/g3zkp/rooms/${roomId}`;
    await this.engine.subscribe(topicName);
    
    const topic = this.topics.get(roomId);
    if (topic) {
      topic.subscribers.add(this.engine.getPeerId());
      topic.stats.subscriberCount = topic.subscribers.size;
    }
    
    await this.requestRoomState(roomId);
  }

  // Matrix: Event broadcast → PubSub publish
  async broadcastToRoom(roomId: string, message: G3ZKPMessage): Promise<BroadcastResult> {
    const topicName = `/g3zkp/rooms/${roomId}`;
    const messageBytes = new TextEncoder().encode(JSON.stringify(message));
    
    const receipt = await this.engine.publishMessage(topicName, messageBytes);
    
    const topic = this.topics.get(roomId);
    if (topic) {
      topic.messages.push(message);
      topic.stats.messageCount++;
      topic.stats.lastMessageTime = new Date();
      if (topic.messages.length > 1000) topic.messages = topic.messages.slice(-1000);
    }

    return { success: true, topic: topicName, timestamp: new Date() };
  }

  // Matrix: To-device messages → Direct P2P
  async sendToDevice(userId: string, deviceId: string, message: ToDeviceMessage): Promise<void> {
    const peerId = await this.findPeerForDevice(userId, deviceId);
    if (!peerId) throw new Error(`Peer not found for ${userId}:${deviceId}`);
    
    const data = new TextEncoder().encode(JSON.stringify(message));
    await this.engine.sendMessage(peerId, data);
  }

  // Matrix: Key distribution → DHT
  async publishKeyUpdate(keyUpdate: KeyUpdate): Promise<void> {
    const key = `/g3zkp/keys/${keyUpdate.userId}/${keyUpdate.deviceId}`;
    const value = new TextEncoder().encode(JSON.stringify(keyUpdate));
    await this.dht?.put(key, value);
    
    const topicName = `/g3zkp/keys/${keyUpdate.userId}`;
    await this.engine.publishMessage(topicName, value);
  }

  // Matrix: Key query → DHT lookup
  async fetchDeviceKeys(userId: string, deviceIds?: string[]): Promise<Record<string, any>> {
    const keys: Record<string, any> = {};
    
    if (deviceIds) {
      for (const deviceId of deviceIds) {
        const key = `/g3zkp/keys/${userId}/${deviceId}`;
        const value = await this.dht?.get(key);
        if (value) keys[deviceId] = JSON.parse(new TextDecoder().decode(value));
      }
    }
    return keys;
  }

  // Matrix: Presence → DHT + PubSub
  async broadcastPresenceUpdate(presence: any): Promise<void> {
    const topicName = `/g3zkp/presence/${presence.user_id}`;
    const presenceBytes = new TextEncoder().encode(JSON.stringify(presence));
    await this.engine.publishMessage(topicName, presenceBytes);
    
    const key = `/g3zkp/presence/${presence.user_id}/current`;
    await this.dht?.put(key, presenceBytes);
  }

  // Matrix: Room directory → DHT query
  async discoverRooms(query: { limit?: number }): Promise<any[]> {
    const rooms: any[] = [];
    const prefix = `/g3zkp/rooms/`;
    const records = await this.dht?.query(prefix) || [];
    
    for (const record of records) {
      const roomInfo = JSON.parse(new TextDecoder().decode(record.value));
      rooms.push(roomInfo);
      if (rooms.length >= (query.limit || 100)) break;
    }
    return rooms;
  }

  // Matrix: Room aliases → IPNS
  async publishToIPNS(path: string, alias: string, options: any): Promise<any> {
    // Publish room alias to IPNS for decentralized discovery
    return { path, alias, ...options };
  }

  private async requestRoomState(roomId: string): Promise<void> {
    const stateKey = `/g3zkp/rooms/${roomId}/state`;
    const stateValue = await this.dht?.get(stateKey);
    if (stateValue) {
      const state = JSON.parse(new TextDecoder().decode(stateValue));
      // Emit room state event
    }
  }

  private async findPeerForDevice(userId: string, deviceId: string): Promise<string | null> {
    const key = `/g3zkp/devices/${userId}/${deviceId}`;
    const value = await this.dht?.get(key);
    if (value) {
      const device = JSON.parse(new TextDecoder().decode(value));
      return device.peerId;
    }
    return null;
  }
}

interface BroadcastResult {
  success: boolean;
  topic: string;
  timestamp: Date;
}

interface KeyUpdate {
  userId: string;
  deviceId: string;
  deviceKeys: any;
  oneTimeKeyCount: number;
  proof: any;
}
```

---

## 5. MATRIX ENDPOINT MAPPING

| Matrix Endpoint | G3ZKP P2P Equivalent |
|-----------------|---------------------|
| `/_matrix/client/r0/sync` | `/g3zkp/1.0.0/sync` stream |
| `/_matrix/client/r0/send/{type}/{txnId}` | PubSub to `/g3zkp/rooms/{id}` |
| `/_matrix/client/r0/rooms/{id}/join` | Subscribe to topic |
| `/_matrix/client/r0/rooms/{id}/leave` | Unsubscribe from topic |
| `/_matrix/client/r0/keys/upload` | DHT put + PubSub |
| `/_matrix/client/r0/keys/query` | DHT query |
| `/_matrix/client/r0/keys/claim` | DHT get + delete |
| `/_matrix/federation/v1/send/{txnId}` | Direct P2P stream |
| `/_matrix/federation/v1/state/{roomId}` | DHT query |

---

*Next: Part 06 - Storage Engine*
