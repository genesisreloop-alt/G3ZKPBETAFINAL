# G3ZKP Implementation Plan - Part 04
## Zero-Knowledge Proof System

---

## 1. CIRCUIT DEFINITIONS

### 1.1 Authentication Circuit

**File: `packages/zkp/circuits/authentication.circom`**

```circom
pragma circom 2.1.3;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/comparators.circom";

template AuthenticationCircuit() {
    // Public inputs
    signal input identityCommitment;
    signal input nullifierHash;
    signal input externalNullifier;
    
    // Private inputs
    signal input identitySecret;
    signal input identityNullifier;
    
    // Output
    signal output valid;
    
    // Verify identity commitment
    component commitmentHasher = Poseidon(2);
    commitmentHasher.inputs[0] <== identitySecret;
    commitmentHasher.inputs[1] <== identityNullifier;
    
    identityCommitment === commitmentHasher.out;
    
    // Verify nullifier hash
    component nullifierHasher = Poseidon(2);
    nullifierHasher.inputs[0] <== identityNullifier;
    nullifierHasher.inputs[1] <== externalNullifier;
    
    nullifierHash === nullifierHasher.out;
    
    valid <== 1;
}

component main {public [identityCommitment, nullifierHash, externalNullifier]} = AuthenticationCircuit();
```

### 1.2 Message Security Circuit

**File: `packages/zkp/circuits/message_security.circom`**

```circom
pragma circom 2.1.3;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/comparators.circom";

template MessageSecurityCircuit() {
    // Public inputs
    signal input messageRoot;
    signal input timestamp;
    signal input senderCommitment;
    signal input receiverCommitment;
    
    // Private inputs
    signal input messageHash;
    signal input encryptionKeyHash;
    signal input senderSecret;
    signal input receiverSecret;
    signal input nonce;
    
    // Outputs
    signal output securityScore;
    signal output valid;
    
    // Verify message integrity
    component msgHasher = Poseidon(3);
    msgHasher.inputs[0] <== messageHash;
    msgHasher.inputs[1] <== encryptionKeyHash;
    msgHasher.inputs[2] <== nonce;
    
    signal computedRoot <== msgHasher.out;
    signal rootValid <== IsEqual()([messageRoot, computedRoot]);
    
    // Verify sender commitment
    component senderHasher = Poseidon(2);
    senderHasher.inputs[0] <== senderSecret;
    senderHasher.inputs[1] <== messageHash;
    signal senderValid <== IsEqual()([senderCommitment, senderHasher.out]);
    
    // Verify receiver commitment  
    component receiverHasher = Poseidon(2);
    receiverHasher.inputs[0] <== receiverSecret;
    receiverHasher.inputs[1] <== messageHash;
    signal receiverValid <== IsEqual()([receiverCommitment, receiverHasher.out]);
    
    // Calculate security score (0-100)
    securityScore <== rootValid * 40 + senderValid * 30 + receiverValid * 30;
    
    // Valid if score >= 85
    component scoreCheck = GreaterEqThan(8);
    scoreCheck.in[0] <== securityScore;
    scoreCheck.in[1] <== 85;
    valid <== scoreCheck.out;
}

component main {public [messageRoot, timestamp, senderCommitment, receiverCommitment]} = MessageSecurityCircuit();
```

---

## 2. ZKP ENGINE

**File: `packages/zkp/src/zkp-engine.ts`**

```typescript
import * as snarkjs from 'snarkjs';
import { ZKProof, ZKProofMetadata } from '@g3zkp/core';
import { CircuitRegistry, CircuitInfo } from './circuit-registry';
import { generateProofId } from '@g3zkp/core';

export interface ProofInputs {
  [key: string]: bigint | bigint[] | string | number;
}

export interface ProofResult {
  proof: ZKProof;
  generationTime: number;
  cached: boolean;
}

export class ZKPEngine {
  private registry: CircuitRegistry;
  private proofCache: Map<string, ZKProof> = new Map();
  private initialized = false;

  constructor() {
    this.registry = new CircuitRegistry();
  }

  async initialize(): Promise<void> {
    if (this.initialized) return;
    await this.registry.loadCircuits();
    this.initialized = true;
  }

  async generateProof(
    circuitId: string,
    inputs: ProofInputs
  ): Promise<ProofResult> {
    const circuit = this.registry.getCircuit(circuitId);
    if (!circuit) {
      throw new Error(`Circuit ${circuitId} not found`);
    }

    const cacheKey = this.getCacheKey(circuitId, inputs);
    const cached = this.proofCache.get(cacheKey);
    if (cached && this.isProofFresh(cached)) {
      return { proof: cached, generationTime: 0, cached: true };
    }

    const startTime = Date.now();

    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
      inputs,
      circuit.wasmPath,
      circuit.zkeyPath
    );

    const generationTime = Date.now() - startTime;

    const zkProof: ZKProof = {
      circuitId,
      proof: this.serializeProof(proof),
      publicSignals: publicSignals.map(s => BigInt(s)),
      metadata: {
        proofId: generateProofId(),
        generationTime,
        circuitConstraints: circuit.constraints,
        timestamp: new Date(),
        proverId: 'local'
      }
    };

    this.proofCache.set(cacheKey, zkProof);
    this.pruneCache();

    return { proof: zkProof, generationTime, cached: false };
  }

  async verifyProof(proof: ZKProof): Promise<boolean> {
    const circuit = this.registry.getCircuit(proof.circuitId);
    if (!circuit) {
      throw new Error(`Circuit ${proof.circuitId} not found`);
    }

    const deserializedProof = this.deserializeProof(proof.proof);
    const publicSignals = proof.publicSignals.map(s => s.toString());

    return await snarkjs.groth16.verify(
      circuit.verificationKey,
      publicSignals,
      deserializedProof
    );
  }

  private serializeProof(proof: any): Uint8Array {
    const json = JSON.stringify(proof);
    return new TextEncoder().encode(json);
  }

  private deserializeProof(data: Uint8Array): any {
    const json = new TextDecoder().decode(data);
    return JSON.parse(json);
  }

  private getCacheKey(circuitId: string, inputs: ProofInputs): string {
    const inputStr = JSON.stringify(inputs, (_, v) =>
      typeof v === 'bigint' ? v.toString() : v
    );
    return `${circuitId}:${inputStr}`;
  }

  private isProofFresh(proof: ZKProof): boolean {
    const age = Date.now() - proof.metadata.timestamp.getTime();
    return age < 5 * 60 * 1000; // 5 minutes
  }

  private pruneCache(): void {
    if (this.proofCache.size > 500) {
      const entries = [...this.proofCache.entries()];
      entries.sort((a, b) => 
        b[1].metadata.timestamp.getTime() - a[1].metadata.timestamp.getTime()
      );
      this.proofCache = new Map(entries.slice(0, 400));
    }
  }
}
```

---

## 3. CIRCUIT REGISTRY

**File: `packages/zkp/src/circuit-registry.ts`**

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

export interface CircuitInfo {
  id: string;
  name: string;
  wasmPath: string;
  zkeyPath: string;
  verificationKey: any;
  constraints: number;
}

export class CircuitRegistry {
  private circuits: Map<string, CircuitInfo> = new Map();
  private basePath: string;

  constructor(basePath: string = './build') {
    this.basePath = basePath;
  }

  async loadCircuits(): Promise<void> {
    const circuitDirs = [
      'authentication',
      'message_security',
      'forward_secrecy',
      'metadata_privacy',
      'composite_security'
    ];

    for (const dir of circuitDirs) {
      try {
        const circuitPath = path.join(this.basePath, dir);
        
        const vkeyPath = path.join(circuitPath, 'verification_key.json');
        const vkeyContent = await fs.readFile(vkeyPath, 'utf-8');
        const verificationKey = JSON.parse(vkeyContent);

        this.circuits.set(dir, {
          id: dir,
          name: dir.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
          wasmPath: path.join(circuitPath, `${dir}.wasm`),
          zkeyPath: path.join(circuitPath, `${dir}.zkey`),
          verificationKey,
          constraints: verificationKey.nPublic || 0
        });

        console.log(`Loaded circuit: ${dir}`);
      } catch (error) {
        console.warn(`Failed to load circuit ${dir}:`, error);
      }
    }
  }

  getCircuit(id: string): CircuitInfo | undefined {
    return this.circuits.get(id);
  }

  listCircuits(): CircuitInfo[] {
    return [...this.circuits.values()];
  }

  hasCircuit(id: string): boolean {
    return this.circuits.has(id);
  }
}
```

---

## 4. CIRCUIT BUILD SCRIPT

**File: `packages/zkp/scripts/build-circuits.sh`**

```bash
#!/bin/bash
set -euo pipefail

CIRCUITS_DIR="./circuits"
BUILD_DIR="./build"
PTAU_FILE="./powersOfTau28_hez_final_15.ptau"

# Download powers of tau if not exists
if [ ! -f "$PTAU_FILE" ]; then
  echo "Downloading powers of tau..."
  curl -L -o "$PTAU_FILE" \
    "https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_15.ptau"
fi

mkdir -p "$BUILD_DIR"

for circuit in authentication message_security forward_secrecy metadata_privacy composite_security; do
  echo "Building circuit: $circuit"
  
  CIRCUIT_DIR="$BUILD_DIR/$circuit"
  mkdir -p "$CIRCUIT_DIR"
  
  # Compile circuit
  circom "$CIRCUITS_DIR/$circuit.circom" \
    --r1cs --wasm --sym \
    -o "$CIRCUIT_DIR"
  
  # Generate zkey
  snarkjs groth16 setup \
    "$CIRCUIT_DIR/$circuit.r1cs" \
    "$PTAU_FILE" \
    "$CIRCUIT_DIR/${circuit}_0000.zkey"
  
  # Contribute to ceremony (in production, use multi-party ceremony)
  echo "random entropy for $circuit" | snarkjs zkey contribute \
    "$CIRCUIT_DIR/${circuit}_0000.zkey" \
    "$CIRCUIT_DIR/$circuit.zkey" \
    --name="G3ZKP Contribution"
  
  # Export verification key
  snarkjs zkey export verificationkey \
    "$CIRCUIT_DIR/$circuit.zkey" \
    "$CIRCUIT_DIR/verification_key.json"
  
  # Cleanup intermediate files
  rm -f "$CIRCUIT_DIR/${circuit}_0000.zkey"
  
  echo "Circuit $circuit built successfully"
done

echo "All circuits built successfully"
```

---

*Next: Part 05 - Network Layer*
