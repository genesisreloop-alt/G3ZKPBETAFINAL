# G3ZKP Implementation Plan - Part 07
## Security Audit System

---

## 1. AUDIT ENGINE

**File: `packages/audit/src/audit-engine.ts`**

```typescript
import { EventEmitter } from '@g3zkp/core';

export enum AuditSeverity {
  INFO = 0,
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3,
  CRITICAL = 4
}

export enum AuditCategory {
  ZKP = 'zkp',
  ENCRYPTION = 'encryption',
  NETWORK = 'network',
  IDENTITY = 'identity',
  PROTOCOL = 'protocol',
  STORAGE = 'storage'
}

export interface SecurityFinding {
  id: string;
  title: string;
  description: string;
  severity: AuditSeverity;
  category: AuditCategory;
  location: { file: string; line: number; column: number };
  evidence: { codeSnippet: string; context: string; proof: string };
  impact: { confidentiality: number; integrity: number; availability: number; score: number };
  remediation: { steps: string[]; difficulty: string; priority: number; references: string[] };
  metadata: { discoveredAt: Date; status: string; tags: string[] };
}

export interface AuditReport {
  id: string;
  timestamp: Date;
  duration: number;
  findings: SecurityFinding[];
  summary: { total: number; critical: number; high: number; medium: number; low: number };
  passed: boolean;
}

interface AuditEvents {
  'finding': SecurityFinding;
  'complete': AuditReport;
  'error': Error;
}

export class SecurityAuditEngine extends EventEmitter<AuditEvents> {
  private auditors: Map<string, any> = new Map();

  async initialize(): Promise<void> {
    // Register auditors
    this.auditors.set('zkp', new ZKPAuditor());
    this.auditors.set('crypto', new CryptoAuditor());
    this.auditors.set('network', new NetworkAuditor());
  }

  async audit(scope: { files: string[] }): Promise<AuditReport> {
    const startTime = Date.now();
    const findings: SecurityFinding[] = [];

    for (const [name, auditor] of this.auditors) {
      try {
        const results = await auditor.audit(scope);
        for (const finding of results) {
          findings.push(finding);
          this.emit('finding', finding);
        }
      } catch (error) {
        this.emit('error', error as Error);
      }
    }

    const report: AuditReport = {
      id: `audit-${Date.now()}`,
      timestamp: new Date(),
      duration: Date.now() - startTime,
      findings,
      summary: {
        total: findings.length,
        critical: findings.filter(f => f.severity === AuditSeverity.CRITICAL).length,
        high: findings.filter(f => f.severity === AuditSeverity.HIGH).length,
        medium: findings.filter(f => f.severity === AuditSeverity.MEDIUM).length,
        low: findings.filter(f => f.severity === AuditSeverity.LOW).length
      },
      passed: findings.filter(f => f.severity >= AuditSeverity.HIGH).length === 0
    };

    this.emit('complete', report);
    return report;
  }
}

class ZKPAuditor {
  async audit(scope: { files: string[] }): Promise<SecurityFinding[]> {
    const findings: SecurityFinding[] = [];
    
    for (const file of scope.files.filter(f => f.endsWith('.circom'))) {
      // Check for common ZKP vulnerabilities
      const content = await this.readFile(file);
      
      // Under-constrained circuits
      if (this.hasUnderConstrainedSignals(content)) {
        findings.push(this.createFinding(
          'Under-constrained signals',
          'Circuit contains signals that are not fully constrained',
          AuditSeverity.CRITICAL,
          AuditCategory.ZKP,
          file
        ));
      }
      
      // Missing range checks
      if (this.missingRangeChecks(content)) {
        findings.push(this.createFinding(
          'Missing range checks',
          'Arithmetic operations may overflow',
          AuditSeverity.HIGH,
          AuditCategory.ZKP,
          file
        ));
      }
    }
    
    return findings;
  }

  private hasUnderConstrainedSignals(content: string): boolean {
    const signalDeclarations = content.match(/signal\s+(input|output)?\s+\w+/g) || [];
    const constraints = content.match(/===|<==|==>|<==/g) || [];
    return signalDeclarations.length > constraints.length * 2;
  }

  private missingRangeChecks(content: string): boolean {
    return content.includes('*') && !content.includes('LessThan') && !content.includes('Num2Bits');
  }

  private async readFile(path: string): Promise<string> {
    const fs = await import('fs/promises');
    return await fs.readFile(path, 'utf-8');
  }

  private createFinding(
    title: string,
    description: string,
    severity: AuditSeverity,
    category: AuditCategory,
    file: string
  ): SecurityFinding {
    return {
      id: `finding-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title,
      description,
      severity,
      category,
      location: { file, line: 0, column: 0 },
      evidence: { codeSnippet: '', context: '', proof: '' },
      impact: { confidentiality: 8, integrity: 8, availability: 2, score: 80 },
      remediation: { steps: [], difficulty: 'medium', priority: 1, references: [] },
      metadata: { discoveredAt: new Date(), status: 'open', tags: [] }
    };
  }
}

class CryptoAuditor {
  async audit(scope: { files: string[] }): Promise<SecurityFinding[]> {
    const findings: SecurityFinding[] = [];
    
    for (const file of scope.files.filter(f => f.endsWith('.ts') || f.endsWith('.js'))) {
      const content = await this.readFile(file);
      
      // Weak random
      if (content.includes('Math.random')) {
        findings.push({
          id: `crypto-random-${Date.now()}`,
          title: 'Insecure Random Number Generator',
          description: 'Math.random() is not cryptographically secure',
          severity: AuditSeverity.CRITICAL,
          category: AuditCategory.ENCRYPTION,
          location: { file, line: 0, column: 0 },
          evidence: { codeSnippet: 'Math.random()', context: '', proof: '' },
          impact: { confidentiality: 10, integrity: 6, availability: 1, score: 95 },
          remediation: {
            steps: ['Use crypto.randomBytes() or crypto.getRandomValues()'],
            difficulty: 'low',
            priority: 1,
            references: ['https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues']
          },
          metadata: { discoveredAt: new Date(), status: 'open', tags: ['randomness'] }
        });
      }
    }
    
    return findings;
  }

  private async readFile(path: string): Promise<string> {
    const fs = await import('fs/promises');
    try {
      return await fs.readFile(path, 'utf-8');
    } catch {
      return '';
    }
  }
}

class NetworkAuditor {
  async audit(scope: { files: string[] }): Promise<SecurityFinding[]> {
    return []; // Network-specific checks
  }
}
```

---

## 2. CONTINUOUS MONITOR

**File: `packages/audit/src/continuous-monitor.ts`**

```typescript
import { SecurityAuditEngine, AuditReport, AuditSeverity } from './audit-engine';
import chokidar from 'chokidar';

export interface Alert {
  type: string;
  severity: AuditSeverity;
  title: string;
  description: string;
  timestamp: Date;
  metadata: Record<string, any>;
}

export class ContinuousSecurityMonitor {
  private auditEngine: SecurityAuditEngine;
  private watcher: chokidar.FSWatcher | null = null;
  private alertHandlers: ((alert: Alert) => void)[] = [];
  private lastAudit: AuditReport | null = null;

  constructor() {
    this.auditEngine = new SecurityAuditEngine();
  }

  async start(watchPaths: string[]): Promise<void> {
    await this.auditEngine.initialize();

    // Run initial audit
    await this.runAudit(watchPaths);

    // Watch for file changes
    this.watcher = chokidar.watch(watchPaths, {
      ignored: /node_modules|\.git|dist/,
      persistent: true,
      ignoreInitial: true
    });

    this.watcher.on('change', async (path) => {
      console.log(`File changed: ${path}`);
      await this.runAudit([path]);
    });

    // Scheduled full audits every 5 minutes
    setInterval(() => this.runAudit(watchPaths), 5 * 60 * 1000);
  }

  async stop(): Promise<void> {
    await this.watcher?.close();
  }

  onAlert(handler: (alert: Alert) => void): void {
    this.alertHandlers.push(handler);
  }

  private async runAudit(files: string[]): Promise<void> {
    try {
      const report = await this.auditEngine.audit({ files });
      this.lastAudit = report;

      // Generate alerts for high/critical findings
      for (const finding of report.findings) {
        if (finding.severity >= AuditSeverity.HIGH) {
          const alert: Alert = {
            type: 'security_finding',
            severity: finding.severity,
            title: finding.title,
            description: finding.description,
            timestamp: new Date(),
            metadata: { findingId: finding.id, category: finding.category }
          };

          for (const handler of this.alertHandlers) {
            handler(alert);
          }
        }
      }
    } catch (error) {
      console.error('Audit failed:', error);
    }
  }

  getLastAudit(): AuditReport | null {
    return this.lastAudit;
  }
}
```

---

## 3. METRICS COLLECTOR

**File: `packages/audit/src/metrics-collector.ts`**

```typescript
export interface SecurityMetrics {
  timestamp: Date;
  auditsPassed: number;
  auditsFailed: number;
  criticalFindings: number;
  highFindings: number;
  averageAuditDuration: number;
  proofGenerationTime: number;
  proofVerificationTime: number;
  activeConnections: number;
  failedAuthentications: number;
}

export class MetricsCollector {
  private metrics: SecurityMetrics[] = [];
  private maxRetention = 1000;

  record(metrics: Partial<SecurityMetrics>): void {
    this.metrics.push({
      timestamp: new Date(),
      auditsPassed: 0,
      auditsFailed: 0,
      criticalFindings: 0,
      highFindings: 0,
      averageAuditDuration: 0,
      proofGenerationTime: 0,
      proofVerificationTime: 0,
      activeConnections: 0,
      failedAuthentications: 0,
      ...metrics
    });

    if (this.metrics.length > this.maxRetention) {
      this.metrics = this.metrics.slice(-this.maxRetention);
    }
  }

  getRecent(count: number = 100): SecurityMetrics[] {
    return this.metrics.slice(-count);
  }

  getAverages(duration: number = 3600000): Partial<SecurityMetrics> {
    const cutoff = Date.now() - duration;
    const recent = this.metrics.filter(m => m.timestamp.getTime() > cutoff);
    
    if (recent.length === 0) return {};

    return {
      criticalFindings: this.avg(recent, 'criticalFindings'),
      highFindings: this.avg(recent, 'highFindings'),
      averageAuditDuration: this.avg(recent, 'averageAuditDuration'),
      proofGenerationTime: this.avg(recent, 'proofGenerationTime')
    };
  }

  private avg(arr: SecurityMetrics[], key: keyof SecurityMetrics): number {
    const sum = arr.reduce((acc, m) => acc + (m[key] as number), 0);
    return sum / arr.length;
  }

  exportPrometheus(): string {
    const latest = this.metrics[this.metrics.length - 1];
    if (!latest) return '';

    return `
g3zkp_audits_passed ${latest.auditsPassed}
g3zkp_audits_failed ${latest.auditsFailed}
g3zkp_critical_findings ${latest.criticalFindings}
g3zkp_high_findings ${latest.highFindings}
g3zkp_audit_duration_seconds ${latest.averageAuditDuration / 1000}
g3zkp_proof_generation_seconds ${latest.proofGenerationTime / 1000}
g3zkp_active_connections ${latest.activeConnections}
g3zkp_failed_authentications ${latest.failedAuthentications}
    `.trim();
  }
}
```

---

*Next: Part 08 - Cross-Platform Clients*
